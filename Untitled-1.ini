#!/usr/bin/env python3
# 简单安全的命令行计算器（支持 + - * / % ** 括号、变量赋值、部分 math 函数）
# 用法:
#  - 交互式: 运行脚本后在提示符输入表达式
#  - 单表达式: python calc.py "2+2*3"
#  - 赋值: x = 3.5
#  - 退出: exit 或 quit 或 Ctrl-C

import ast
import math
import sys

ALLOWED_BINOP = {
    ast.Add: lambda a, b: a + b,
    ast.Sub: lambda a, b: a - b,
    ast.Mult: lambda a, b: a * b,
    ast.Div: lambda a, b: a / b,
    ast.Mod: lambda a, b: a % b,
    ast.Pow: lambda a, b: a ** b,
    ast.FloorDiv: lambda a, b: a // b,
}
ALLOWED_UNARY = {
    ast.UAdd: lambda a: +a,
    ast.USub: lambda a: -a,
}

# 允许的 math 函数和常量
_math_names = [n for n in dir(math) if not n.startswith("_")]
MATH_ENV = {n: getattr(math, n) for n in _math_names}

def eval_node(node, env):
    if isinstance(node, ast.Expression):
        return eval_node(node.body, env)
    if isinstance(node, ast.Constant):  # numbers
        if isinstance(node.value, (int, float, complex)):
            return node.value
        raise ValueError("不支持的常量类型")
    if isinstance(node, ast.Num):  # for older AST
        return node.n
    if isinstance(node, ast.BinOp):
        op_type = type(node.op)
        if op_type not in ALLOWED_BINOP:
            raise ValueError("不支持的运算符")
        left = eval_node(node.left, env)
        right = eval_node(node.right, env)
        return ALLOWED_BINOP[op_type](left, right)
    if isinstance(node, ast.UnaryOp):
        op_type = type(node.op)
        if op_type not in ALLOWED_UNARY:
            raise ValueError("不支持的一元运算符")
        operand = eval_node(node.operand, env)
        return ALLOWED_UNARY[op_type](operand)
    if isinstance(node, ast.Name):
        if node.id in env:
            return env[node.id]
        if node.id in MATH_ENV:
            return MATH_ENV[node.id]
        raise NameError(f"未定义的名称: {node.id}")
    if isinstance(node, ast.Call):
        if not isinstance(node.func, ast.Name):
            raise ValueError("仅允许调用简单名称函数")
        fname = node.func.id
        if fname not in MATH_ENV:
            raise NameError(f"不允许的函数: {fname}")
        func = MATH_ENV[fname]
        args = [eval_node(a, env) for a in node.args]
        return func(*args)
    if isinstance(node, ast.Tuple):
        return tuple(eval_node(elt, env) for elt in node.elts)
    raise ValueError(f"不支持的语法: {type(node).__name__}")

def parse_expr(expr):
    try:
        return ast.parse(expr, mode="eval")
    except SyntaxError as e:
        raise ValueError("语法错误") from e

def parse_assign(src):
    try:
        mod = ast.parse(src, mode="exec")
    except SyntaxError as e:
        raise ValueError("语法错误") from e
    if len(mod.body) != 1 or not isinstance(mod.body[0], ast.Assign):
        raise ValueError("只支持简单的赋值语句，例如: x = 1+2")
    assign = mod.body[0]
    if len(assign.targets) != 1 or not isinstance(assign.targets[0], ast.Name):
        raise ValueError("只允许将值赋给单个变量名")
    target = assign.targets[0].id
    value_node = assign.value
    # wrap value_node in Expression for eval_node
    expr_node = ast.Expression(value_node)
    return target, expr_node

def eval_expr_str(expr_str, env):
    expr_str = expr_str.strip()
    if not expr_str:
        return None
    # assignment?
    if "=" in expr_str:
        target, expr_node = parse_assign(expr_str)
        val = eval_node(expr_node, env)
        env[target] = val
        return f"{target} = {val}"
    # expression
    expr_node = parse_expr(expr_str)
    val = eval_node(expr_node, env)
    return val

def repl(env):
    try:
        while True:
            try:
                s = input("calc> ").strip()
            except EOFError:
                break
            if not s:
                continue
            if s.lower() in ("exit", "quit"):
                break
            try:
                out = eval_expr_str(s, env)
                if out is not None:
                    print(out)
            except Exception as e:
                print("错误:", e)
    except KeyboardInterrupt:
        print()

def main():
    env = {"pi": math.pi, "e": math.e}
    env.update({})  # placeholder for user variables
    if len(sys.argv) > 1:
        expr = " ".join(sys.argv[1:])
        try:
            res = eval_expr_str(expr, env)
            if res is not None:
                print(res)
        except Exception as e:
            print("错误:", e)
        return
    repl(env)

if __name__ == "__main__":
    main()